"""Models for the game app."""

from uuid import uuid4
from django.db import models
from django.contrib.auth import get_user_model
from django.dispatch import receiver
from django.db.models.signals import post_save
from numpy import mean, std

User = get_user_model()  # users


class UserType(models.Model):
    user = models.OneToOneField(User, on_delete=models.PROTECT)
    admin = models.BooleanField(default=False)

    class Meta:
        abstract = True
        db_table = 'UserType'


@receiver(post_save, sender=User)
def create_user_profile(sender, instance, created, **kwargs):
    if created:
        UserType.objects.create(user=instance)


@receiver(post_save, sender=User)
def save_user_profile(sender, instance, **kwargs):
    instance.profile.save()


def deserialize_user(user):  # USER ID
    """Deserialize user instance to JSON."""
    return {
        'id': user.id, 'username': user.username, 'email': user.email,
        'first_name': user.first_name, 'last_name': user.last_name}


class TrackableDateModel(models.Model):
    """Abstract model to Track the creation/updated date for a model."""
    create_date = models.DateTimeField(auto_now_add=True)
    update_date = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True
        db_table = 'ModelTrack'


def _generate_unique_uri():
    """Generates a unique uri for the game session."""
    return str(uuid4()).replace('-', '')[:15]


class GameSession(TrackableDateModel):
    """ A Game. The uri's are generated by taking the first 15 characters from a UUID """
    owner = models.ForeignKey(User, on_delete=models.PROTECT, limited_choices_to={
                              UserType.admin: True})  # owner have to have admin rights
    uri = models.URLField(default=_generate_unique_uri,
                          primary_key=True)  # GAME ID, and verification code
    date_created = models.DateTimeField(auto_now_add=True)
    game_play = models.BooleanField(default=True)

    def __str__(self):
        return(self.uri)

    def __unicode__(self):
        return(str(self))

    def getGameStatus(self, game_status):
        if game_status:
            return(self.GameSession.objects.filter(game_play=True))
        else:
            return(self.GameSession.objects.filter(game_play=False).count())

    class Meta:
        db_table = 'GameID'


class GameSessionBasic(TrackableDateModel):
    game_id = models.OneToOneField(GameSession, on_delete=models.PROTECT)
    num_suppliers = models.IntegerField()  # 1-5
    num_buyers = models.IntegerField()  # 1-5
    current_period = models.IntegerField()  # keep updating

    class Meta:
        db_table = 'GameInfo'

    def getCurrentPeriod(self, UID):
        q = self.GameSessionBasic.objects.filter(game_id=UID)
        return(q.current_period)


class GameSessionMember(TrackableDateModel):
    """Store all  users in a chat session."""
    user_types = (('S', 'Supplier'), ('B', 'Buyer'), ('GM', 'Game Manager'))
    game_id = models.ForeignKey(GameSession, on_delete=models.PROTECT)
    user = models.ManyToManyField(User, on_delete=models.PROTECT)
    user_type = models.CharField(max_length=1, choices=user_types, default='B')

    def getUserList(self, UID):
        q = self.GameSessionMember.objects.filter(game_id=UID)
        aList = []
        for i in q:
            aList.append([i.user, i.user_type])
        return(aList)

    class Meta:
        unique_together = ('user', 'game_id')
        db_table = 'GameMembers'


def isGameReady(UID):
    q = GameSessionBasic.objects.filter(game_id=UID)
    suppliers_needed = q.num_suppliers
    buyers_needed = q.num_buyers

    r = GameSessionMember.objects.filter(game_id=UID)
    suppliers=r.objects.filter(user_type='S').count()
    buyers=r.objects.filter(user_type='B').count()

    if suppliers_needed != suppliers:
        if buyers_needed!=buyers:
            #throw error, need more suppliers & buyers
            return(False)
        else:
            #throw error, need more suppliers
            return(False)
    else:
        if buyers_needed!=buyers:
            #throw error, need more buyers
            return(False)
        else:
            return(True)

class GameSessionSubmission(TrackableDateModel):
    """Store submissions for a session. """
    user = models.ForeignKey(User, on_delete=models.PROTECT)
    game_session = models.ForeignKey(GameSession, on_delete=models.PROTECT)
    period = models.ForeignKey(
        GameSession, on_delete=models.PROTECT, default=1)
    forecast1 = models.IntegerField()
    forecast2 = models.IntegerField()
    forecast3 = models.IntegerField()
    forecast4 = models.IntegerField()
    order = models.IntegerField()
    date_created = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return(str(self.user) + 'in period' + str(self.period) + 'in game' + str(self.game_session))

    def __unicode__(self):
        return(str(self))

    def to_json(self):
        """deserialize message to JSON."""
        return{'user': deserialize_user(self.user), 'Forecast 1': self.forecast1, 'Forecast 2': self.forecast2, 'Forecast 3': self.forecast3, 'Forecast 4': self.forecast4, 'Order': self.order}

    class Meta:
        unique_together = ('user', 'game_session', 'period')


class GameBuyerData(TrackableDateModel):
    game_session = models.ForeignKey(
        GameSession, related_name='buyer_game', on_delete=models.PROTECT)
    user = models.ForeignKey(User, related_name='buyer',
                             on_delete=models.PROTECT)
    period = models.ForeignKey(
        GameSession, related_name="buyer_period", on_delete=models.PROTECT)

    dedicated_inventory = models.IntegerField()
    order_demand = models.IntegerField(default=0)
    on_order = models.IntegerField()
    received_shipment = models.IntegerField()
    fg_inventory = models.IntegerField(default=0)
    backlog = models.IntegerField(default=0)

    mean_p1 = models.IntegerField()
    mean_p2 = models.IntegerField()
    mean_p3 = models.IntegerField()
    mean_p4 = models.IntegerField()
    mean_current = models.IntegerField()
    sd_p1 = models.IntegerField()
    sd_p1 = models.IntegerField()
    sd_p3 = models.IntegerField()
    sd_p4 = models.IntegerField()
    sd_current = models.IntegerField()

    fill_rate = models.FloatField()  # avg service level
    smoothed_acc = models.FloatField()
    avg_profit = models.FloatField()
    accumulated_profit = models.FloatField()

    class Meta:
        unique_together = ('user', 'game_session', 'period')


class GameSupplierSettings(TrackableDateModel):
    game_session = models.ForeignKey(
        GameSession, related_name='supplier_settings_game', on_delete=models.PROTECT)
    user = models.ForeignKey(
        User, related_name='supplier_settings', on_delete=models.PROTECT)
    allocaton_rule = models.CharField(max_length=1, choices=(
        ('M', 'Manual'), ('P', 'Proportional'), ('U', 'Uniform'), ('F', 'Forecast Accuracy')))
    prod_strategy = models.CharField(max_length=1, choices=(
        ('H', 'High'), ('M', 'Medium'), ('L', 'Low')))
    supplier_avg_fill_rate = models.FloatField()

    class Meta:
        unique_together = ('user', 'game_session')


class GameSupplierData(TrackableDateModel):
    game_session = models.ForeignKey(
        GameSession, related_name='supplier_game', on_delete=models.PROTECT)
    user = models.ForeignKey(
        User, related_name='supplier_user', on_delete=models.PROTECT)
    period = models.ForeignKey(
        GameSession, related_name="supplier_period", on_delete=models.PROTECT)
    fill_rate = models.FloatField()
    inventory_level = models.IntegerField()
    profit = models.FloatField()
    orders_received = models.IntegerField()
    quantity_shipped = models.IntegerField()
    production_quantity = models.IntegerField()
    back_orders = models.IntegerField()
    revenue = models.FloatField()
    production_cost = models.FloatField()
    inventory_cost = models.FloatField()
    backlog_cost = models.FloatField()

    class Meta:
        unique_together = ('user', 'game_session', 'period')


class GameSettings(TrackableDateModel):
    # managed by game manager
    game_session = models.ForeignKey(
        GameSession, related_name='settings', on_delete=models.PROTECT)
    exp_smooth_coeff = models.FloatField(default=0.3)
    percent_remaining = models.FloatField(default=0.9)
    percent_reassigned = models.FloatField(default=0.5)
    num_periods = models.IntegerField(default=50)
    dedicated_period = models.IntegerField(default=1)
    buyer_lead_time = models.IntegerField(default=0)
    seed = models.IntegerField(default=2)
    supplier_backlog = models.BooleanField(default=True)
    overall_supply_health = models.BooleanField(default=True)
    reallocate_inventory = models.BooleanField(default=True)
    demand_process = models.CharField(max_length=1, choices=(
        ('S', 'Stationary'), ('L', 'LowHigh'), ('D', 'Diffusion')))


class VisibilityGameSettings(TrackableDateModel):
    game_session = models.ForeignKey(
        GameSession, related_name='visibility', on_delete=models.PROTECT)
    supplier_buyer_inventory = models.BooleanField(default=True)
    supplier_buyer_demand = models.BooleanField(default=True)
    ded_inv_buyer1 = models.BooleanField(default=False)
    ded_inv_buyer2 = models.BooleanField(default=False)
    ded_inv_buyer3 = models.BooleanField(default=False)
    ded_inv_buyer4 = models.BooleanField(default=False)
    ded_inv_buyer5 = models.BooleanField(default=False)


class GameParameterSettings(TrackableDateModel):
    game_session = models.ForeignKey(
        GameSession, related_name='parameter', on_delete=models.PROTECT)
    lead_time = models.IntegerField(default=4)
    s_production_cost = models.FloatField(default=0.5)
    s_holding_cost = models.FloatField(default=0.1)
    s_wholesale_price = models.FloatField(default=1)
    s_min_build = models.FloatField(default=0)
    s_max_capacity = models.FloatField(default=1000)

    b_holding_cost_small = models.FloatField(default=0.15)
    b_holding_cost_medium = models.FloatField(default=0.15)
    b_holding_cost_big = models.FloatField(default=0.15)
    b_backlog_cost_small = models.FloatField(default=0.45)
    b_backlog_cost_medium = models.FloatField(default=0.45)
    b_backlog_cost_big = models.FloatField(default=0.45)
    b_retail_pric_small = models.FloatField(default=2)
    b_retail_price_medium = models.FloatField(default=2)
    b_retail_price_big = models.FloatField(default=2)
    b_mean_demand_small = models.FloatField(default=61)
    b_mean_demand_medium = models.FloatField(default=111)
    b_mean_demand_big = models.FloatField(default=200)
    b_sd_demand_small = models.FloatField(default=6.1)
    b_sd_demand_medium = models.FloatField(default=11.1)
    b_sd_demand_big = models.FloatField(default=40)

    buyer_size = (('S', 'small'), ('M', 'medium'), ('B', 'big'))

    buyer1_size = models.CharField(
        max_length=1, choices=buyer_size, default=('B', 'big'))
    buyer2_size = models.CharField(
        max_length=1, choices=buyer_size, default=('B', 'big'))
    buyer3_size = models.CharField(
        max_length=1, choices=buyer_size, default=('B', 'big'))
    buyer4_size = models.CharField(
        max_length=1, choices=buyer_size, default=('B', 'big'))
    buyer5_size = models.CharField(
        max_length=1, choices=buyer_size, default=('B', 'big'))

    competing_supplier = models.BooleanField(default=False)
    competing_supplier_charge = models.IntegerField(default=3)


class CommentLog(TrackableDateModel):
    game_session = models.ForeignKey(
        GameSession, related_name='comment_game', on_delete=models.PROTECT)
    user = models.ForeignKey(
        User, related_name='comment_user', on_delete=models.PROTECT)
    period = models.ForeignKey(
        GameSession, related_name='comment_period', on_delete=models.PROTECT)
    comments = models.TextField(null=True)

    class Meta:
        unique_together = ('user', 'game_session', 'period')

    # def save(self, *args, **kw):
    #     self.full_name = '{0} {1}'.format(self.first_name, self.last_name)
    #     super(Instructor, self).save(*args, **kw)

#     def contact_default():
#     return {"email": "to1@example.com"}

# contact_info = JSONField("ContactInfo", default=contact_default)

# To create a recursive relationship – an object that has a many-to-one relationship with itself – use models.ForeignKey('self', on_delete=models.CASCADE).
